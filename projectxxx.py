# -*- coding: utf-8 -*-
"""Projectxxx.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17QroKCLUWAnupvM8Aggc5qGi7mdnE7zD
"""

import requests
import pandas as pd

# Define the base URL for the API
url = "https://api.themoviedb.org/3/movie/popular"
headers = {
    "Authorization": "Bearer eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiIxNmNmMTgzYzdmYmJhMzI2ZTlhYWZmMGFjNDY4NzhkMyIsIm5iZiI6MTczMTIzOTU3Mi4wMTkyMzgyLCJzdWIiOiI2NzJmNmMzMjU3YjMwMWYzYzkzMThmZjIiLCJzY29wZXMiOlsiYXBpX3JlYWQiXSwidmVyc2lvbiI6MX0.T4dZkizY8S38YA1K4Y59gUXT0u-Zjrcych_IqPQVMTk"
}

# Set up a list to collect movie data
movies_data = []

# Loop through pages to collect at least 10,000 movies
for page in range(1, 501):  # Fetching 500 pages, 20 movies each
    response = requests.get(url, headers=headers, params={"page": page})

    # Check if the request was successful
    if response.status_code != 200:
        print(f"Error: Unable to fetch data for page {page}")
        continue

    data = response.json()

    # Add movie data to the list
    for movie in data['results']:
        movie_id = movie['id']
        # Fetch detailed movie info including budget, revenue, production details, etc.
        details_url = f"https://api.themoviedb.org/3/movie/{movie_id}"
        details_response = requests.get(details_url, headers=headers)
        details_data = details_response.json()

        movies_data.append({
            "title": movie.get('title', 'N/A'),
            "rating": movie.get('vote_average', 'N/A'),
            "release_date": movie.get('release_date', 'N/A'),
            "popularity": movie.get('popularity', 'N/A'),
            "genre_ids": movie.get('genre_ids', []),
            "budget": details_data.get('budget', 'N/A'),
            "revenue": details_data.get('revenue', 'N/A'),
            "vote_count": movie.get('vote_count', 'N/A'),
            "original_language": movie.get('original_language', 'N/A'),
            "production_companies": [company['name'] for company in details_data.get('production_companies', [])],
            "production_countries": [country['name'] for country in details_data.get('production_countries', [])],
            "runtime": details_data.get('runtime', 'N/A'),
            "release_month": pd.to_datetime(movie.get('release_date', 'N/A')).month if movie.get('release_date') else 'N/A'
        })

    # Stop if we have already fetched 10,000 movies
    if len(movies_data) >= 10000:
        break

# Convert to DataFrame for easier analysis
df_movies = pd.DataFrame(movies_data)

# Display the first few rows to verify
print("Data Collection Complete. First Few Rows:")
print(df_movies.head())

# Save the DataFrame to a CSV for future use
df_movies.to_csv("movies_data_10000_en  iched.csv", index=False)

"""Check for Missing Values:
Replace N/A or None with appropriate defaults or drop if irrelevant.
"""

# Check for missing values
print(df_movies.isnull().sum())

# Fill missing budget or revenue with median values
df_movies['budget'] = df_movies['budget'].replace('N/A', 0)
df_movies['revenue'] = df_movies['revenue'].replace('N/A', 0)
df_movies['runtime'] = df_movies['runtime'].replace('N/A', df_movies['runtime'].median())

"""Standardize Columns:
Budget and Revenue: Convert to numeric for easy analysis.
Release Month: Useful for trend analysis by seasonality.
"""

# Convert budget and revenue to numeric
df_movies['budget'] = pd.to_numeric(df_movies['budget'], errors='coerce')
df_movies['revenue'] = pd.to_numeric(df_movies['revenue'], errors='coerce')

"""Hereâ€™s Some Code for These Steps:
Step 1: Handle Outliers in Budget and Revenue
"""

# Calculate IQR to detect outliers in 'budget' and 'revenue'
Q1_budget = df_movies['budget'].quantile(0.25)
Q3_budget = df_movies['budget'].quantile(0.75)
IQR_budget = Q3_budget - Q1_budget

# Define lower and upper bounds for budget
lower_bound_budget = Q1_budget - 1.5 * IQR_budget
upper_bound_budget = Q3_budget + 1.5 * IQR_budget

# Clip the outliers for 'budget'
df_movies['budget'] = df_movies['budget'].clip(lower=lower_bound_budget, upper=upper_bound_budget)

# Repeat the same for revenue
Q1_revenue = df_movies['revenue'].quantile(0.25)
Q3_revenue = df_movies['revenue'].quantile(0.75)
IQR_revenue = Q3_revenue - Q1_revenue

lower_bound_revenue = Q1_revenue - 1.5 * IQR_revenue
upper_bound_revenue = Q3_revenue + 1.5 * IQR_revenue

# Clip the outliers for 'revenue'
df_movies['revenue'] = df_movies['revenue'].clip(lower=lower_bound_revenue, upper=upper_bound_revenue)

"""Step 2: Convert Genre IDs to Names

If you have a genre ID dictionary (e.g., {28: 'Action', 12: 'Adventure'}), you can convert IDs to names:
"""

# Example dictionary mapping genre IDs to names
genre_dict = {
    28: 'Action', 12: 'Adventure', 16: 'Animation', 35: 'Comedy',
    80: 'Crime', 99: 'Documentary', 18: 'Drama', 10751: 'Family',
    14: 'Fantasy', 36: 'History', 27: 'Horror', 10402: 'Music',
    9648: 'Mystery', 10749: 'Romance', 878: 'Science Fiction',
    10770: 'TV Movie', 53: 'Thriller', 10752: 'War', 37: 'Western'
}

# Apply the genre_dict to convert genre IDs to names
df_movies['genres'] = df_movies['genre_ids'].apply(lambda x: [genre_dict.get(genre_id, 'Unknown') for genre_id in x])

# Drop genre_ids column as we won't need it after conversion
df_movies.drop(columns=['genre_ids'], inplace=True)

import numpy as np

# Check if 'imdb_rating' and 'rotten_tomatoes_rating' are in your DataFrame columns
if 'imdb_rating' in df_movies.columns and 'rotten_tomatoes_rating' in df_movies.columns:
    # Create the combined rating column by averaging the existing ratings
    df_movies['combined_rating'] = df_movies.apply(
        lambda row: np.nanmean([row['imdb_rating'], row['rotten_tomatoes_rating']])
        if not (pd.isna(row['imdb_rating']) and pd.isna(row['rotten_tomatoes_rating']))
        else np.nan, axis=1
    )
else:
    print("Error: One or both of the ratings columns ('imdb_rating', 'rotten_tomatoes_rating') are missing.")

# Verify if the combined_rating column was created successfully
print(df_movies.head())

"""

```
IMDb Ratings: Generated random ratings between 5.0 and 9.0. This is a typical range for most movies.
Rotten Tomatoes Ratings: Generated random ratings between 50 and 100 to simulate percentage-based ratings.
```

"""

import numpy as np

# Adding placeholder ratings for demonstration purposes
# Generating random IMDb ratings between 5 and 9
df_movies['imdb_rating'] = np.random.uniform(5.0, 9.0, len(df_movies))

# Generating random Rotten Tomatoes ratings between 50 and 100 (assuming percentage ratings)
df_movies['rotten_tomatoes_rating'] = np.random.uniform(50, 100, len(df_movies))

# Displaying the first few rows to verify
print(df_movies.head())

"""To ensure both ratings are comparable, Rotten Tomatoes ratings are divided by 10 to match the scale of IMDb ratings (typically out of 10).
The combined rating is then calculated as the mean of both scores.
"""

# Create the combined rating column by averaging IMDb and Rotten Tomatoes ratings
df_movies['combined_rating'] = df_movies.apply(
    lambda row: np.nanmean([row['imdb_rating'], row['rotten_tomatoes_rating'] / 10])  # Dividing Rotten Tomatoes by 10 to bring it in the same scale as IMDb
    if not (pd.isna(row['imdb_rating']) and pd.isna(row['rotten_tomatoes_rating']))
    else np.nan, axis=1
)

# Display the first few rows to verify the combined rating
print(df_movies[['title', 'imdb_rating', 'rotten_tomatoes_rating', 'combined_rating']].head())

# Calculate the correlation matrix with the combined rating
correlation_matrix = df_movies[['budget', 'revenue', 'popularity', 'vote_count', 'combined_rating']].corr()

# Visualize the correlation matrix using a heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5)
plt.title('Correlation Matrix of Key Movie Features')
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Scatter plot of Budget vs Revenue with regression line
plt.figure(figsize=(12, 8))
sns.regplot(x='budget', y='revenue', data=df_movies, scatter_kws={'alpha':0.6}, line_kws={"color":"red"})
plt.xlabel('Budget (in USD)', fontsize=14)
plt.ylabel('Revenue (in USD)', fontsize=14)
plt.title('Relationship between Budget and Revenue', fontsize=16, weight='bold')
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Step 1: Handle missing values in the budget column
# Replace missing budget values with 0
df_movies['budget'].fillna(0, inplace=True)

# Step 2: Redefine budget bins to ensure they're strictly increasing
# Use np.linspace to generate bins for categorization
max_budget = df_movies['budget'].max()
bins = np.linspace(0, max_budget, num=4)  # Creates 3 bins plus 1 upper boundary (strictly increasing)
labels = ['Low Budget', 'Medium Budget', 'High Budget']

# Step 3: Categorize movies based on budget
df_movies['budget_category'] = pd.cut(df_movies['budget'], bins=bins, labels=labels, include_lowest=True)

# Step 4: Verify if the budget category was assigned correctly
print(df_movies[['title', 'budget', 'budget_category']].head())

# Step 5: Calculate the average vote count for each budget category
avg_vote_count = df_movies.groupby('budget_category')['vote_count'].mean().reset_index()

# Step 6: Plot a bar chart to show the average vote count for each budget category
plt.figure(figsize=(10, 6))
sns.barplot(x='budget_category', y='vote_count', data=avg_vote_count, palette='viridis')
plt.xlabel('Budget Category', fontsize=14)
plt.ylabel('Average Vote Count', fontsize=14)
plt.title('Average Vote Count by Budget Category', fontsize=16, weight='bold')
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()

# Scatter plot of Popularity vs Vote Count
plt.figure(figsize=(12, 8))
sns.scatterplot(x='popularity', y='vote_count', data=df_movies, alpha=0.6, color='purple', edgecolor='k')
plt.xlabel('Popularity Score', fontsize=14)
plt.ylabel('Vote Count', fontsize=14)
plt.title('Popularity vs Vote Count', fontsize=16, weight='bold')
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Step 1: Handle missing values in key columns
# Replace missing budget and revenue values with 0 to avoid issues later
df_movies['budget'].fillna(0, inplace=True)
df_movies['revenue'].fillna(0, inplace=True)
df_movies['popularity'].fillna(0, inplace=True)

# Step 2: Create the 'famous' column
# Define thresholds for "famous" movies (top 25% for revenue and popularity)
high_revenue_threshold = df_movies['revenue'].quantile(0.75)
high_popularity_threshold = df_movies['popularity'].quantile(0.75)

# Create a new column to label "famous" movies
df_movies['famous'] = ((df_movies['revenue'] >= high_revenue_threshold) &
                       (df_movies['popularity'] >= high_popularity_threshold))

# Verify if the famous column is created correctly
print(df_movies[['title', 'revenue', 'popularity', 'famous']].head())

# Step 3: Redefine budget bins to ensure they're strictly increasing
# Use np.linspace to generate bins for categorization
max_budget = df_movies['budget'].max()
bins = np.linspace(0, max_budget, num=4)  # Creates 3 bins plus 1 upper boundary (strictly increasing)
labels = ['Low Budget', 'Medium Budget', 'High Budget']

# Step 4: Categorize movies based on budget
df_movies['budget_category'] = pd.cut(df_movies['budget'], bins=bins, labels=labels, include_lowest=True)

# Step 5: Verify if the budget category was assigned correctly
print(df_movies[['title', 'budget', 'budget_category']].head())

# Step 6: Calculate the average vote count for each budget category
avg_vote_count = df_movies.groupby('budget_category')['vote_count'].mean().reset_index()

# Step 7: Plot a bar chart to show the average vote count for each budget category
plt.figure(figsize=(10, 6))
sns.barplot(x='budget_category', y='vote_count', data=avg_vote_count, palette='viridis')
plt.xlabel('Budget Category', fontsize=14)
plt.ylabel('Average Vote Count', fontsize=14)
plt.title('Average Vote Count by Budget Category', fontsize=16, weight='bold')
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Step 1: Handle missing values in key columns
# Replace missing budget, revenue, and popularity values with 0 to avoid issues
df_movies['budget'].fillna(0, inplace=True)
df_movies['revenue'].fillna(0, inplace=True)
df_movies['popularity'].fillna(0, inplace=True)

# Step 2: Create the 'famous' column
# Define thresholds for "famous" movies (top 25% for revenue and popularity)
high_revenue_threshold = df_movies['revenue'].quantile(0.75)
high_popularity_threshold = df_movies['popularity'].quantile(0.75)

# Create a new column to label "famous" movies
df_movies['famous'] = ((df_movies['revenue'] >= high_revenue_threshold) &
                       (df_movies['popularity'] >= high_popularity_threshold))

# Step 3: Explode the genres column properly and reset the index to avoid duplicate labels
# Make sure genres are properly parsed from strings to lists
df_movies['genres'] = df_movies['genres'].apply(lambda x: eval(x) if isinstance(x, str) else x)
df_genres_exploded = df_movies.explode('genres').reset_index(drop=True)

# Step 4: Filter only famous movies
famous_movies = df_genres_exploded[df_genres_exploded['famous'] == True]

# Step 5: Create a count plot to show the frequency of genres among famous movies
plt.figure(figsize=(10, 7))  # Made the figure smaller
sns.countplot(y='genres', data=famous_movies, order=famous_movies['genres'].value_counts().index, palette='coolwarm')
plt.xlabel('Number of Movies', fontsize=12)
plt.ylabel('Genre', fontsize=12)
plt.title('Frequency of Genres among Famous Movies', fontsize=14, weight='bold')
plt.show()

# Step 6: Box plot of budget by genre
plt.figure(figsize=(12, 8))  # Made the figure smaller
sns.boxplot(x='budget', y='genres', data=df_genres_exploded, showfliers=False, palette='Spectral')
plt.xlabel('Budget (in USD)', fontsize=12)
plt.ylabel('Genre', fontsize=12)
plt.title('Budget Distribution by Genre', fontsize=14, weight='bold')
plt.show()

# Step 7: Box plot of revenue by genre
plt.figure(figsize=(12, 8))  # Made the figure smaller
sns.boxplot(x='revenue', y='genres', data=df_genres_exploded, showfliers=False, palette='Spectral')
plt.xlabel('Revenue (in USD)', fontsize=12)
plt.ylabel('Genre', fontsize=12)
plt.title('Revenue Distribution by Genre', fontsize=14, weight='bold')
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Creating an improved scatter plot of Budget vs Revenue with additional styling for better readability
plt.figure(figsize=(12, 8))
plt.scatter(df_movies['budget'], df_movies['revenue'], alpha=0.6, edgecolor='k', color='#1f77b4', linewidth=0.5)

# Add labels, title, and a trendline for better understanding
plt.xlabel('Budget (in USD)', fontsize=14)
plt.ylabel('Revenue (in USD)', fontsize=14)
plt.title('Budget vs Revenue of Movies', fontsize=16, weight='bold')

# Customizing grid lines to make the plot more visually appealing
plt.grid(True, linestyle='--', linewidth=0.7, alpha=0.6)

# Highlight key areas for more interactivity
plt.axhline(y=df_movies['revenue'].mean(), color='r', linestyle='--', linewidth=1, label='Average Revenue')
plt.axvline(x=df_movies['budget'].mean(), color='g', linestyle='--', linewidth=1, label='Average Budget')

# Adding a trendline to visualize the relationship
z = np.polyfit(df_movies['budget'], df_movies['revenue'], 1)
p = np.poly1d(z)
plt.plot(df_movies['budget'], p(df_movies['budget']), color='orange', linestyle='-', linewidth=2, label='Trendline')

# Adding a legend
plt.legend()

# Show the plot
plt.show()

"""Distribution of Popularity:"""